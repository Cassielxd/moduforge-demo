<script lang="ts">
import { defineComponent, ref, reactive, onMounted, onUnmounted, nextTick, watch } from "vue";
import type { PropType } from "vue";
import { ElMessage, ElMessageBox, ElDialog, ElButton, ElColorPicker, ElIcon } from "element-plus";
// @ts-ignore
import { Tabulator } from 'tabulator-tables';
// @ts-ignore
import type { RowComponent, CellComponent, TabulatorConfig } from 'tabulator-tables';
import 'tabulator-tables/dist/css/tabulator.min.css';
import { Plus, Edit, Delete, CopyDocument, Brush, Folder, Document } from '@element-plus/icons-vue';

// --- Data Interfaces ---
interface TableItem {
  id: number | string;
  [key: string]: any;
}

export interface TableColumn {
  prop: string;
  label: string;
  minWidth?: number;
  width?: number;
  align?: "left" | "center" | "right";
  type?: "date";
}

export default defineComponent({
  name: "RightTablePanel",
  components: {
    ElDialog,
    ElButton,
    ElColorPicker,
    ElIcon,
    Plus,
    Edit,
    Delete,
    CopyDocument,
    Brush,
    Folder,
    Document,
  },
  props: {
    tableData: {
      type: Array as PropType<TableItem[]>,
      required: true,
    },
    tableColumns: {
      type: Array as PropType<TableColumn[]>,
      required: true,
    },
    isTreeTable: {
      type: Boolean,
      default: false,
    },
  },
  emits: [
    "update:tableData",
    "add-row",
    "add-child",
    "edit-row",
    "delete-row",
    "copy-row",
  ],
  setup(props, { emit, expose }) {
    const localTableData = ref<TableItem[]>(props.tableData);
    const tableRef = ref<HTMLElement>();
    const tabulator = ref<Tabulator | null>(null);

    const tableContextMenuVisible = ref(false);
    const tableContextMenuPosition = reactive({ x: 0, y: 0 });
    const currentTableItem = ref<TableItem | null>(null);
    const currentRowKey = ref<string | number | null>(null);

    // È¢úËâ≤ÈÄâÊã©Áõ∏ÂÖ≥
    const colorDialogVisible = ref(false);
    const colorValue = ref("#409EFF");

    // Ê∑ªÂä†ÁºñËæëÊ†áÂøó
    const isEditing = ref(false);

    // ÂàùÂßãÂåñ Tabulator
    const initTabulator = () => {
      if (!tableRef.value) return;

      // ËΩ¨Êç¢ÂàóÈÖçÁΩÆ
      const columns = [
        // Â¶ÇÊûúÊòØÊ†ëÂΩ¢Ë°®Ê†ºÔºåÊ∑ªÂä†Ê†ëÂΩ¢Âàó
        ...(props.isTreeTable ? [{
          title: "",
          field: "tree_control",
          width: 150,
          headerSort: false,
          formatter: "tree",
          headerClick: false,
          cellClick: false,
        }] : [{
          title: "",
          width: 50,
          headerSort: false,
          formatter: () => ""
        }]),
        // Êï∞ÊçÆÂàó
        ...props.tableColumns.map(col => ({
          title: col.label,
          field: col.prop,
          width: col.width || col.minWidth || 120,
          headerSort: true,
          editor: "input",
          formatter: (cell: CellComponent) => {
            const data = cell.getRow().getData();
            const value = data[col.prop];

            if (props.isTreeTable && col.prop === 'name') {
              const iconHtml = data.type === 'folder'
                ? '<i class="folder-icon">üìÅ</i>'
                : '<i class="file-icon">üìÑ</i>';
              return `<div class="tree-name-cell">${iconHtml}<span>${value || ''}</span></div>`;
            }

            if (props.isTreeTable && col.prop === 'type') {
              const typeText = data.type === 'folder' ? 'Êñá‰ª∂Â§π' : 'Êñá‰ª∂';
              const typeClass = data.type === 'folder' ? 'folder-tag' : 'file-tag';
              return `<span class="type-tag ${typeClass}">${typeText}</span>`;
            }

            if (col.prop === "size" && data.type === "folder") {
              return "-";
            }

            return value || '';
          },
          cellEdited: (cell: CellComponent) => {
            const row = cell.getRow();
            const data = row.getData();
            isEditing.value = true; // ËÆæÁΩÆÁºñËæëÊ†áÂøó
            localTableData.value = tabulator.value?.getData() || [];
            emit("update:tableData", localTableData.value);

            // Âª∂ËøüÈáçÁΩÆÁºñËæëÊ†áÂøó
            setTimeout(() => {
              isEditing.value = false;
            }, 100);
          }
        }))
      ];

      // ÈÖçÁΩÆ Tabulator
      const config: any = {
        data: localTableData.value,
        columns: columns,
        layout: "fitColumns",
        height: "100%",
        rowContextMenu: [
          {
            label: "Ê∑ªÂä†Ë°å",
            action: (e: Event, row: RowComponent) => {
              currentTableItem.value = row.getData() as TableItem;
              emit("add-row", currentTableItem.value);
            }
          },
          {
            label: "ÁºñËæë",
            action: (e: Event, row: RowComponent) => {
              currentTableItem.value = row.getData() as TableItem;
              emit("edit-row", currentTableItem.value);
            }
          },
          {
            label: "Âà†Èô§",
            action: (e: Event, row: RowComponent) => {
              currentTableItem.value = row.getData() as TableItem;
              emit("delete-row", currentTableItem.value);
            }
          },
          {
            label: "Â§çÂà∂",
            action: (e: Event, row: RowComponent) => {
              currentTableItem.value = row.getData() as TableItem;
              emit("copy-row", currentTableItem.value);
            }
          },
          {
            label: "Ê∑ªÂä†Â≠êÈ°π",
            action: (e: Event, row: RowComponent) => {
              currentTableItem.value = row.getData() as TableItem;
              debugger;
              emit("add-child", currentTableItem.value, row);
            }
          },
          {
            label: "ËÆæÁΩÆËæπÊ°ÜÈ¢úËâ≤",
            action: (e: Event, row: RowComponent) => {
              currentTableItem.value = row.getData() as TableItem;
              openColorDialog();
            }
          }
        ],
        rowFormatter: (row: RowComponent) => {
          const data = row.getData();
          if (data.color && data.color.trim()) {
            const element = row.getElement();
            element.style.border = `2px solid ${data.color}`;
            element.classList.add('colored-border');
          }
        }
      };

      // Â¶ÇÊûúÊòØÊ†ëÂΩ¢Ë°®Ê†ºÔºåÊ∑ªÂä†Ê†ëÂΩ¢ÈÖçÁΩÆ
      if (props.isTreeTable) {
        config.dataTree = true;
        config.dataTreeChildField = "children";
        config.dataTreeStartExpanded = false;
      }

      tabulator.value = new Tabulator(tableRef.value, config);

      // ÁõëÂê¨Ë°åÈÄâÊã©
      tabulator.value.on("rowClick", (e: Event, row: RowComponent) => {
        currentRowKey.value = row.getData().id;

        // Ê∏ÖÈô§ÊâÄÊúâË°åÁöÑÈÄâ‰∏≠Áä∂ÊÄÅ
        tabulator.value?.getRows().forEach((r: RowComponent) => {
          r.getElement().classList.remove('row-selected');
        });

        // ‰∏∫ÂΩìÂâçÈÄâ‰∏≠Ë°åÊ∑ªÂä†ÈÄâ‰∏≠Ê†∑Âºè
        row.getElement().classList.add('row-selected');
      });
    };

    const handleTableContextMenu = (row: TableItem, column: any, event: MouseEvent) => {
      event.preventDefault();
      currentTableItem.value = row;
      tableContextMenuPosition.x = event.clientX;
      tableContextMenuPosition.y = event.clientY;
      tableContextMenuVisible.value = true;
      document.addEventListener("click", closeTableContextMenu);
    };

    const closeTableContextMenu = () => {
      tableContextMenuVisible.value = false;
      document.removeEventListener("click", closeTableContextMenu);
    };

    const handleTableCommand = (command: string) => {
      if (!currentTableItem.value) return;

      switch (command) {
        case "add-row":
          emit("add-row", currentTableItem.value);
          break;
        case "edit":
          emit("edit-row", currentTableItem.value);
          break;
        case "delete":
          emit("delete-row", currentTableItem.value);
          break;
        case "copy":
          emit("copy-row", currentTableItem.value);
          break;
        case "add-child":
          emit("add-child", currentTableItem.value);
          break;
      }
      tableContextMenuVisible.value = false;
    };

    const handleAddTableRow = () => {
      emit("add-row");
    };

    const openColorDialog = () => {
      colorValue.value = currentTableItem.value?.color || "#409EFF";
      colorDialogVisible.value = true;
      tableContextMenuVisible.value = false;
    };

    const handleColorSubmit = () => {
      if (!colorValue.value) {
        ElMessage.warning("ËØ∑ÈÄâÊã©È¢úËâ≤");
        return;
      }
      if (currentTableItem.value && tabulator.value) {
        // Êõ¥Êñ∞ Tabulator ‰∏≠ÁöÑÊï∞ÊçÆ
        const rows = tabulator.value.getRows();
        const targetRow = rows.find((row: RowComponent) => row.getData().id === currentTableItem.value!.id);
        if (targetRow) {
          targetRow.update({ ...targetRow.getData(), color: colorValue.value });
          localTableData.value = tabulator.value.getData();
          emit("update:tableData", localTableData.value);
        }
      }
      colorDialogVisible.value = false;
    };

    // ËÆæÁΩÆÂΩìÂâçÈÄâ‰∏≠Ë°åÁöÑÊñπÊ≥ïÔºå‰æõÁà∂ÁªÑ‰ª∂Ë∞ÉÁî®
    const setCurrentRow = (rowId: string | number) => {
      currentRowKey.value = rowId;
      if (tabulator.value) {
        // ‰ΩøÁî® nextTick Á°Æ‰øùÊï∞ÊçÆÂ∑≤Êõ¥Êñ∞Âπ∂Ê∏≤ÊüìÂÆåÊàê
        nextTick(() => {
          // Ê∑ªÂä†‰∏Ä‰∏™Â∞èÂª∂ËøüÔºåÁ°Æ‰øùÊï∞ÊçÆÁõëÂê¨Âô®ÂÆåÊàêÊõ¥Êñ∞
          setTimeout(() => {
            if (!tabulator.value) return;

            const rows = tabulator.value.getRows();

            // Ê∏ÖÈô§ÊâÄÊúâË°åÁöÑÈÄâ‰∏≠Áä∂ÊÄÅ
            rows.forEach((r: RowComponent) => {
              r.getElement().classList.remove('row-selected');
            });

            const targetRow = rows.find((row: RowComponent) => row.getData().id === rowId);
            if (targetRow) {
              targetRow.select();
              // Ê∑ªÂä†Ëá™ÂÆö‰πâÈÄâ‰∏≠Ê†∑Âºè
              targetRow.getElement().classList.add('row-selected');

              // Â¶ÇÊûúÊòØÊ†ëÂΩ¢Ë°®Ê†ºÔºåÁ°Æ‰øùÁõÆÊ†áË°åÂèØËßÅÔºàÊªöÂä®Âà∞ËßÜÂõæ‰∏≠Ôºâ
              if (props.isTreeTable) {
                try {
                  targetRow.getElement().scrollIntoView({
                    behavior: 'smooth',
                    block: 'nearest'
                  });
                } catch (error) {
                  console.warn('ÊªöÂä®Âà∞ÁõÆÊ†áË°åÂ§±Ë¥•:', error);
                }
              }
            } else {
              console.log('Êú™ÊâæÂà∞Ë¶ÅÈÄâ‰∏≠ÁöÑË°å:', rowId);
              console.log('ÂèØÁî®ÁöÑË°åID:', rows.map((r: RowComponent) => r.getData().id));
            }
          }, 100); // 100ms Âª∂ËøüÁ°Æ‰øùÊï∞ÊçÆÊõ¥Êñ∞ÂÆåÊàê
        });
      }
    };

    // ÁÆÄÂåñÔºöÁßªÈô§Â±ïÂºÄÂäüËÉΩÔºåÂè™‰øùÁïôÂü∫Êú¨ÁöÑÊ†ëÂΩ¢Ë°®Ê†ºÊòæÁ§∫

    // Êõ¥Êñ∞Êï∞ÊçÆÁöÑÊñπÊ≥ï
    const updateData = (newData: TableItem[]) => {
      const previousSelectedId = currentRowKey.value;
      localTableData.value = newData;
      if (tabulator.value) {
        tabulator.value.setData(newData);

        // Êï∞ÊçÆÊõ¥Êñ∞ÂêéÊÅ¢Â§çÈÄâ‰∏≠Áä∂ÊÄÅ
        if (previousSelectedId) {
          nextTick(() => {
            setCurrentRow(previousSelectedId);
          });
        }
      }
    };

    // Âà∑Êñ∞Ë°®Ê†ºÊï∞ÊçÆÔºàÂº∫Âà∂ÈáçÊñ∞Ê∏≤ÊüìÔºâ
    const refreshTable = () => {
      if (tabulator.value) {
        tabulator.value.setData(localTableData.value);
      }
    };

    onMounted(() => {
      nextTick(() => {
        initTabulator();
      });
    });

    onUnmounted(() => {
      if (tabulator.value) {
        tabulator.value.destroy();
      }
    });

    // ÁõëÂê¨Êï∞ÊçÆÂèòÂåñ
    watch(() => props.tableData, (newData) => {
      console.log('props.tableData ÂèòÂåñ:', newData);
      localTableData.value = newData;
      if (tabulator.value) {
        // Ê£ÄÊü•ÊòØÂê¶ÊòØÁºñËæëÊìç‰ΩúÂØºËá¥ÁöÑÊï∞ÊçÆÂèòÂåñ
        const currentData = tabulator.value.getData();
        const isEditOperation = isEditing.value || (currentData.length === newData.length);

        if (isEditOperation) {
          // Â¶ÇÊûúÊòØÁºñËæëÊìç‰ΩúÔºåÂè™Êõ¥Êñ∞Êï∞ÊçÆÔºå‰∏çÈáçÂª∫Ë°®Ê†º
          // ‰øùÂ≠òÂΩìÂâçÁöÑÂ±ïÂºÄÁä∂ÊÄÅ
          const expandedRows = tabulator.value.getRows().filter((row: RowComponent) => row.isTreeExpanded()).map((row: RowComponent) => row.getData().id);

          // Êõ¥Êñ∞Êï∞ÊçÆ
          tabulator.value.setData(newData);

          // ÊÅ¢Â§çÂ±ïÂºÄÁä∂ÊÄÅ
          nextTick(() => {
            if (tabulator.value) {
              expandedRows.forEach((id: string | number) => {
                const row = tabulator.value!.getRows().find((r: RowComponent) => r.getData().id === id);
                if (row && row.getData().children && row.getData().children.length > 0) {
                  row.treeExpand();
                }
              });
            }
          });
        } else {
          // Â¶ÇÊûúÊòØÁªìÊûÑÂèòÂåñÔºàÊ∑ªÂä†/Âà†Èô§Ë°åÔºâÔºåÊâçÈáçÂª∫Ë°®Ê†º
          tabulator.value.setData([]);
          nextTick(() => {
            if (tabulator.value) {
              tabulator.value.setData(newData);
            }
          });
        }
      }
    }, { deep: true, immediate: true });

    // Ê∏ÖÈô§ÈÄâ‰∏≠Áä∂ÊÄÅÁöÑÊñπÊ≥ï
    const clearSelection = () => {
      currentRowKey.value = null;
      if (tabulator.value) {
        tabulator.value.getRows().forEach((r: RowComponent) => {
          r.getElement().classList.remove('row-selected');
        });
        tabulator.value.deselectRow();
      }
    };

    // ========== Êñ∞Â¢ûÊñπÊ≥ï ==========

    // Ëé∑ÂèñÂΩìÂâçÈÄâ‰∏≠Ë°åÊï∞ÊçÆ
    const getCurrentRow = () => {
      if (!tabulator.value || !currentRowKey.value) return null;
      const rows = tabulator.value.getRows();
      return rows.find((row: RowComponent) => row.getData().id === currentRowKey.value)?.getData() || null;
    };

    // Ëé∑ÂèñÊâÄÊúâË°åÊï∞ÊçÆ
    const getAllData = () => {
      return tabulator.value?.getData() || [];
    };

    // Ê†πÊçÆIDËé∑ÂèñË°åÊï∞ÊçÆ
    const getRowById = (id: string | number) => {
      if (!tabulator.value) return null;
      const rows = tabulator.value.getRows();
      return rows.find((row: RowComponent) => row.getData().id === id)?.getData() || null;
    };

    // Ê†πÊçÆÊù°‰ª∂Êü•ÊâæË°å
    const findRows = (predicate: (row: TableItem) => boolean) => {
      if (!tabulator.value) return [];
      const rows = tabulator.value.getRows();
      return rows
        .map((row: RowComponent) => row.getData() as TableItem)
        .filter(predicate);
    };

    // Êõ¥Êñ∞ÊåáÂÆöË°åÁöÑÊï∞ÊçÆ
    const updateRow = (id: string | number, newData: Partial<TableItem>) => {
      if (!tabulator.value) return false;
      const rows = tabulator.value.getRows();
      const targetRow = rows.find((row: RowComponent) => row.getData().id === id);
      if (targetRow) {
        targetRow.update({ ...targetRow.getData(), ...newData });
        localTableData.value = tabulator.value.getData();
        emit("update:tableData", localTableData.value);
        return true;
      }
      return false;
    };

    // Âà†Èô§ÊåáÂÆöË°å
    const deleteRow = (id: string | number) => {
      if (!tabulator.value) return false;
      const rows = tabulator.value.getRows();
      const targetRow = rows.find((row: RowComponent) => row.getData().id === id);
      if (targetRow) {
        // ‰ΩøÁî®Á±ªÂûãÊñ≠Ë®ÄÊù•ËÆøÈóÆ delete ÊñπÊ≥ï
        (targetRow as any).delete();
        localTableData.value = tabulator.value.getData();
        emit("update:tableData", localTableData.value);
        return true;
      }
      return false;
    };

    // Ê∑ªÂä†Êñ∞Ë°å
    const addRow = (rowData: TableItem) => {
      if (!tabulator.value) return false;
      // ‰ΩøÁî®Á±ªÂûãÊñ≠Ë®ÄÊù•ËÆøÈóÆ addRow ÊñπÊ≥ï
      (tabulator.value as any).addRow(rowData);
      localTableData.value = tabulator.value.getData();
      emit("update:tableData", localTableData.value);
      return true;
    };

    // Ê†ëÂΩ¢Ë°®Ê†ºÁõ∏ÂÖ≥ÊñπÊ≥ï
    const expandAll = () => {
      if (!tabulator.value || !props.isTreeTable) return;
      const rows = tabulator.value.getRows();
      rows.forEach((row: RowComponent) => {
        if (row.getData().children && row.getData().children.length > 0) {
          row.treeExpand();
        }
      });
    };

    const collapseAll = () => {
      if (!tabulator.value || !props.isTreeTable) return;
      const rows = tabulator.value.getRows();
      rows.forEach((row: RowComponent) => {
        if (row.isTreeExpanded()) {
          row.treeCollapse();
        }
      });
    };

    const expandRow = (id: string | number) => {
      if (!tabulator.value || !props.isTreeTable) return false;
      const rows = tabulator.value.getRows();
      const targetRow = rows.find((row: RowComponent) => row.getData().id === id);
      if (targetRow && targetRow.getData().children && targetRow.getData().children.length > 0) {
        targetRow.treeExpand();
        return true;
      }
      return false;
    };

    const collapseRow = (id: string | number) => {
      if (!tabulator.value || !props.isTreeTable) return false;
      const rows = tabulator.value.getRows();
      const targetRow = rows.find((row: RowComponent) => row.getData().id === id);
      if (targetRow && targetRow.isTreeExpanded()) {
        targetRow.treeCollapse();
        return true;
      }
      return false;
    };

    const isRowExpanded = (id: string | number) => {
      if (!tabulator.value || !props.isTreeTable) return false;
      const rows = tabulator.value.getRows();
      const targetRow = rows.find((row: RowComponent) => row.getData().id === id);
      return targetRow ? targetRow.isTreeExpanded() : false;
    };

    // Ëé∑ÂèñÂ±ïÂºÄÁöÑË°åIDÂàóË°®
    const getExpandedRows = () => {
      if (!tabulator.value || !props.isTreeTable) return [];
      const rows = tabulator.value.getRows();
      return rows.filter((row: RowComponent) => row.isTreeExpanded()).map((row: RowComponent) => row.getData().id);
    };

    // ËÆæÁΩÆÂ±ïÂºÄÁä∂ÊÄÅ
    const setExpandedRows = (ids: (string | number)[]) => {
      if (!tabulator.value || !props.isTreeTable) return;
      const rows = tabulator.value.getRows();

      // ÂÖàÊî∂Ëµ∑ÊâÄÊúâË°å
      rows.forEach((row: RowComponent) => {
        if (row.isTreeExpanded()) {
          row.treeCollapse();
        }
      });

      // Â±ïÂºÄÊåáÂÆöÁöÑË°å
      ids.forEach((id: string | number) => {
        const targetRow = rows.find((row: RowComponent) => row.getData().id === id);
        if (targetRow && targetRow.getData().children && targetRow.getData().children.length > 0) {
          targetRow.treeExpand();
        }
      });
    };

    // ÊéíÂ∫èÁõ∏ÂÖ≥ÊñπÊ≥ï
    const sortBy = (field: string, dir: 'asc' | 'desc' = 'asc') => {
      if (!tabulator.value) return;
      (tabulator.value as any).setSort(field, dir);
    };

    const clearSort = () => {
      if (!tabulator.value) return;
      (tabulator.value as any).clearSort();
    };

    // ËøáÊª§Áõ∏ÂÖ≥ÊñπÊ≥ï
    const setFilter = (field: string, type: string, value: any) => {
      if (!tabulator.value) return;
      (tabulator.value as any).setFilter(field, type, value);
    };

    const clearFilter = () => {
      if (!tabulator.value) return;
      (tabulator.value as any).clearFilter();
    };

    // ÂàÜÈ°µÁõ∏ÂÖ≥ÊñπÊ≥ï
    const setPage = (page: number) => {
      if (!tabulator.value) return;
      (tabulator.value as any).setPage(page);
    };

    const getCurrentPage = () => {
      if (!tabulator.value) return 1;
      return (tabulator.value as any).getPage();
    };

    const getPageSize = () => {
      if (!tabulator.value) return 10;
      return (tabulator.value as any).getPageSize();
    };

    const setPageSize = (size: number) => {
      if (!tabulator.value) return;
      (tabulator.value as any).setPageSize(size);
    };

    // ÈÄâÊã©Áõ∏ÂÖ≥ÊñπÊ≥ï
    const selectRow = (id: string | number) => {
      if (!tabulator.value) return false;
      const rows = tabulator.value.getRows();
      const targetRow = rows.find((row: RowComponent) => row.getData().id === id);
      if (targetRow) {
        targetRow.select();
        return true;
      }
      return false;
    };

    const deselectRow = (id: string | number) => {
      if (!tabulator.value) return false;
      const rows = tabulator.value.getRows();
      const targetRow = rows.find((row: RowComponent) => row.getData().id === id);
      if (targetRow) {
        (targetRow as any).deselect();
        return true;
      }
      return false;
    };

    const getSelectedRows = () => {
      if (!tabulator.value) return [];
      return (tabulator.value as any).getSelectedRows().map((row: RowComponent) => row.getData());
    };

    const selectAll = () => {
      if (!tabulator.value) return;
      (tabulator.value as any).selectRow();
    };

    const deselectAll = () => {
      if (!tabulator.value) return;
      tabulator.value.deselectRow();
    };

    // ÊªöÂä®Áõ∏ÂÖ≥ÊñπÊ≥ï
    const scrollToRow = (id: string | number, position: 'start' | 'center' | 'end' = 'center') => {
      if (!tabulator.value) return false;
      const rows = tabulator.value.getRows();
      const targetRow = rows.find((row: RowComponent) => row.getData().id === id);
      if (targetRow) {
        targetRow.getElement().scrollIntoView({
          behavior: 'smooth',
          block: position
        });
        return true;
      }
      return false;
    };

    const scrollToTop = () => {
      if (!tabulator.value) return;
      const tableElement = (tabulator.value as any).getElement();
      if (tableElement) {
        tableElement.scrollTop = 0;
      }
    };

    const scrollToBottom = () => {
      if (!tabulator.value) return;
      const tableElement = (tabulator.value as any).getElement();
      if (tableElement) {
        tableElement.scrollTop = tableElement.scrollHeight;
      }
    };

    // ÂØºÂá∫Áõ∏ÂÖ≥ÊñπÊ≥ï
    const exportToCSV = (filename?: string) => {
      if (!tabulator.value) return;
      (tabulator.value as any).download('csv', filename || 'table-data.csv');
    };

    const exportToJSON = (filename?: string) => {
      if (!tabulator.value) return;
      (tabulator.value as any).download('json', filename || 'table-data.json');
    };

    const exportToPDF = (filename?: string) => {
      if (!tabulator.value) return;
      (tabulator.value as any).download('pdf', filename || 'table-data.pdf');
    };

    // Ë°®Ê†ºÁä∂ÊÄÅÊñπÊ≥ï
    const getTableState = () => {
      if (!tabulator.value) return null;
      return {
        currentPage: (tabulator.value as any).getPage(),
        pageSize: (tabulator.value as any).getPageSize(),
        sort: (tabulator.value as any).getSorters(),
        filter: (tabulator.value as any).getFilters(),
        selectedRows: (tabulator.value as any).getSelectedRows().map((row: RowComponent) => row.getData().id),
        expandedRows: props.isTreeTable ? getExpandedRows() : [],
        currentRow: currentRowKey.value
      };
    };

    const setTableState = (state: any) => {
      if (!tabulator.value) return;

      if (state.sort) {
        (tabulator.value as any).setSort(state.sort);
      }

      if (state.filter) {
        (tabulator.value as any).setFilter(state.filter);
      }

      if (state.pageSize) {
        (tabulator.value as any).setPageSize(state.pageSize);
      }

      if (state.currentPage) {
        (tabulator.value as any).setPage(state.currentPage);
      }

      if (state.expandedRows && props.isTreeTable) {
        setExpandedRows(state.expandedRows);
      }

      if (state.currentRow) {
        setCurrentRow(state.currentRow);
      }
    };

    // ÈáçÊñ∞ÂàùÂßãÂåñË°®Ê†º
    const reinitializeTable = () => {
      if (tabulator.value) {
        tabulator.value.destroy();
      }
      nextTick(() => {
        initTabulator();
      });
    };

    // Ëé∑ÂèñË°®Ê†ºÁªüËÆ°‰ø°ÊÅØ
    const getTableStats = () => {
      if (!tabulator.value) return null;
      const rows = tabulator.value.getRows();
      return {
        totalRows: rows.length,
        visibleRows: rows.filter((row: RowComponent) => (row as any).isVisible()).length,
        selectedRows: (tabulator.value as any).getSelectedRows().length,
        expandedRows: props.isTreeTable ? getExpandedRows().length : 0,
        currentPage: (tabulator.value as any).getPage(),
        totalPages: (tabulator.value as any).getPageMax()
      };
    };

    // Êö¥Èú≤ÊñπÊ≥ïÁªôÁà∂ÁªÑ‰ª∂
    expose({
      setCurrentRow,
      updateData,
      clearSelection,
      refreshTable,
      getCurrentRow,
      getAllData,
      getRowById,
      findRows,
      updateRow,
      deleteRow,
      addRow,
      expandAll,
      collapseAll,
      expandRow,
      collapseRow,
      isRowExpanded,
      getExpandedRows,
      setExpandedRows,
      sortBy,
      clearSort,
      setFilter,
      clearFilter,
      setPage,
      getCurrentPage,
      getPageSize,
      setPageSize,
      selectRow,
      deselectRow,
      getSelectedRows,
      selectAll,
      deselectAll,
      scrollToRow,
      scrollToTop,
      scrollToBottom,
      exportToCSV,
      exportToJSON,
      exportToPDF,
      getTableState,
      setTableState,
      reinitializeTable,
      getTableStats,
    });

    return {
      localTableData,
      tableRef,
      tabulator,
      tableContextMenuVisible,
      tableContextMenuPosition,
      handleTableContextMenu,
      handleTableCommand,
      closeTableContextMenu,
      handleAddTableRow,
      colorDialogVisible,
      colorValue,
      openColorDialog,
      handleColorSubmit,
      currentRowKey,
      setCurrentRow,
      clearSelection,
      refreshTable,
    };
  },
});
</script>

<template>
  <div class="table-panel-container">
    <el-dialog v-model="colorDialogVisible" title="ËÆæÁΩÆËæπÊ°ÜÈ¢úËâ≤" width="300px">
      <el-color-picker v-model="colorValue" />
      <template #footer>
        <el-button @click="colorDialogVisible = false">ÂèñÊ∂à</el-button>
        <el-button type="primary" @click="handleColorSubmit">Á°ÆÂÆö</el-button>
      </template>
    </el-dialog>

    <!-- Tabulator Ë°®Ê†ºÂÆπÂô® -->
    <div ref="tableRef" class="tabulator-table"></div>
  </div>
</template>

<style scoped>
.table-panel-container {
  display: flex;
  flex-direction: column;
  height: 100%;
}

.tabulator-table {
  flex: 1;
  height: 100%;
}

/* Tabulator Ëá™ÂÆö‰πâÊ†∑Âºè */
:deep(.tabulator) {
  border: 1px solid #e4e7ed;
  border-radius: 4px;
  background: #fff;
}

:deep(.tabulator .tabulator-header) {
  background: #f5f7fa;
  border-bottom: 1px solid #e4e7ed;
}

:deep(.tabulator .tabulator-header .tabulator-col) {
  background: #f5f7fa;
  border-right: 1px solid #e4e7ed;
  font-weight: 600;
  color: #606266;
}

:deep(.tabulator .tabulator-row) {
  border-bottom: 1px solid #e4e7ed;
  position: relative;
}

:deep(.tabulator .tabulator-row .tabulator-cell) {
  border-right: 1px solid #e4e7ed;
  padding: 8px 12px;
}

/* ÊúâÈ¢úËâ≤ËæπÊ°ÜÁöÑË°åÔºåË∞ÉÊï¥ÂçïÂÖÉÊ†ºËæπÊ°Ü */
:deep(.tabulator .tabulator-row.colored-border .tabulator-cell) {
  border-right: none !important;
}

:deep(.tabulator .tabulator-row:hover) {
  background-color: #f5f7fa;
}

:deep(.tabulator .tabulator-row.tabulator-selected) {
  background-color: #ecf5ff;
}

/* Ëá™ÂÆö‰πâË°åÈÄâ‰∏≠Ê†∑Âºè */
:deep(.tabulator .tabulator-row.row-selected) {
  background-color: #e6f7ff !important;
  border-left: 1px solid #1890ff !important;
  position: relative;
}

/* ÈÄâ‰∏≠Ë°åÊÇ¨ÂÅúÊïàÊûú */
:deep(.tabulator .tabulator-row.row-selected:hover) {
  background-color: #bae7ff !important;
}

/* ÈÄâ‰∏≠Ë°åÁöÑÂçïÂÖÉÊ†ºÊ†∑Âºè */
:deep(.tabulator .tabulator-row.row-selected .tabulator-cell) {
  border-color: #91d5ff;
  font-weight: 500;
}

/* Á°Æ‰øùÊúâÈ¢úËâ≤ËæπÊ°ÜÁöÑÈÄâ‰∏≠Ë°åÊ†∑ÂºèÊ≠£Á°ÆÂè†Âä† */
:deep(.tabulator .tabulator-row.row-selected.colored-border) {
  box-shadow: inset 0 0 0 2px #1890ff, 0 0 0 2px currentColor;
}

/* Ê†ëÂΩ¢Ë°®Ê†ºÊ†∑Âºè */
.tree-name-cell {
  display: flex;
  align-items: center;
  gap: 8px;
}

.folder-icon {
  color: #e6a23c;
  font-size: 16px;
}

.file-icon {
  color: #909399;
  font-size: 16px;
}

.type-tag {
  padding: 2px 8px;
  border-radius: 4px;
  font-size: 12px;
  font-weight: 500;
}

.folder-tag {
  background: #fdf6ec;
  color: #e6a23c;
  border: 1px solid #f5dab1;
}

.file-tag {
  background: #f4f4f5;
  color: #909399;
  border: 1px solid #d3d4d6;
}

/* Ê†ëÂΩ¢ÊéßÂà∂ÂàóÊ†∑Âºè */
:deep(.tabulator .tabulator-cell[data-field="tree_control"]) {
  padding: 4px 8px;
  text-align: center;
}

:deep(.tabulator .tabulator-cell[data-field="tree_control"] .tabulator-tree-control) {
  display: inline-block;
  width: 16px;
  height: 16px;
  line-height: 16px;
  text-align: center;
  cursor: pointer;
  border-radius: 2px;
  transition: background-color 0.2s;
}

:deep(.tabulator .tabulator-cell[data-field="tree_control"] .tabulator-tree-control:hover) {
  background-color: #f0f0f0;
}

:deep(.tabulator .tabulator-cell[data-field="tree_control"] .tabulator-tree-control .tabulator-tree-control-expand) {
  color: #409eff;
  font-weight: bold;
}

:deep(.tabulator .tabulator-cell[data-field="tree_control"] .tabulator-tree-control .tabulator-tree-control-collapse) {
  color: #409eff;
  font-weight: bold;
}

/* Âè≥ÈîÆËèúÂçïÊ†∑ÂºèË¶ÜÁõñ */
:deep(.tabulator-menu) {
  background: #fff;
  border: 1px solid #e4e7ed;
  box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
  border-radius: 4px;
  padding: 4px 0;
  font-size: 14px;
}

:deep(.tabulator-menu .tabulator-menu-item) {
  padding: 8px 16px;
  cursor: pointer;
  transition: background 0.2s;
}

:deep(.tabulator-menu .tabulator-menu-item:hover) {
  background-color: #f5f7fa;
}

/* ÊúâËæπÊ°ÜÈ¢úËâ≤ÁöÑË°åÊ†∑Âºè */
:deep(.tabulator .tabulator-row.colored-border) {
  border-width: 2px !important;
  border-style: solid !important;
  margin: 1px 0 !important;
  /* Èò≤Ê≠¢ËæπÊ°ÜÈáçÂè† */
}

/* Á°Æ‰øùËæπÊ°ÜÈ¢úËâ≤Âú®ÊÇ¨ÂÅúÊó∂‰πü‰øùÊåÅ */
:deep(.tabulator .tabulator-row.colored-border:hover) {
  border-width: 2px !important;
  border-style: solid !important;
}
</style>
